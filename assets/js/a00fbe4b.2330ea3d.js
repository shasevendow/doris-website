"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[53823],{15680:(e,t,i)=>{i.d(t,{xA:()=>d,yg:()=>y});var n=i(296540);function l(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function a(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){l(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function r(e,t){if(null==e)return{};var i,n,l=function(e,t){if(null==e)return{};var i,n,l={},o=Object.keys(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||(l[i]=e[i]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(l[i]=e[i])}return l}var s=n.createContext({}),c=function(e){var t=n.useContext(s),i=t;return e&&(i="function"==typeof e?e(t):a(a({},t),e)),i},d=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var i=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),m=c(i),p=l,y=m["".concat(s,".").concat(p)]||m[p]||u[p]||o;return i?n.createElement(y,a(a({ref:t},d),{},{components:i})):n.createElement(y,a({ref:t},d))}));function y(e,t){var i=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=i.length,a=new Array(o);a[0]=p;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[m]="string"==typeof e?e:l,a[1]=r;for(var c=2;c<o;c++)a[c]=i[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,i)}p.displayName="MDXCreateElement"},635812:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var n=i(58168),l=(i(296540),i(15680));const o={title:"BloomFilter Index",language:"en"},a=void 0,r={unversionedId:"table-design/index/bloomfilter",id:"table-design/index/bloomfilter",title:"BloomFilter Index",description:"\x3c!--",source:"@site/docs/table-design/index/bloomfilter.md",sourceDirName:"table-design/index",slug:"/table-design/index/bloomfilter",permalink:"/docs/dev/table-design/index/bloomfilter",draft:!1,tags:[],version:"current",frontMatter:{title:"BloomFilter Index",language:"en"},sidebar:"docs",previous:{title:"Sort Key and Prefix Index",permalink:"/docs/dev/table-design/index/prefix-index"},next:{title:"N-Gram BloomFilter Index",permalink:"/docs/dev/table-design/index/ngram-bloomfilter-index"}},s={},c=[{value:"Create BloomFilter index",id:"create-bloomfilter-index",level:3},{value:"View BloomFilter index",id:"view-bloomfilter-index",level:3},{value:"Delete BloomFilter index",id:"delete-bloomfilter-index",level:3},{value:"Modify BloomFilter index",id:"modify-bloomfilter-index",level:3},{value:"<strong>BloomFilter usage scenarios</strong>",id:"bloomfilter-usage-scenarios",level:3},{value:"<strong>BloomFilter use precautions</strong>",id:"bloomfilter-use-precautions",level:3}],d={toc:c},m="wrapper";function u(e){let{components:t,...o}=e;return(0,l.yg)(m,(0,n.A)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,l.yg)("p",null,"BloomFilter is a fast search algorithm for multi-hash function mapping proposed by Bloom in 1970. Usually used in some occasions where it is necessary to quickly determine whether an element belongs to a set, but is not strictly required to be 100% correct, BloomFilter has the following characteristics:"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},"A highly space-efficient probabilistic data structure used to check whether an element is in a set."),(0,l.yg)("li",{parentName:"ul"},"For a call to detect whether an element exists, BloomFilter will tell the caller one of two results: it may exist or it must not exist."),(0,l.yg)("li",{parentName:"ul"},"The disadvantage is that there is a misjudgment, telling you that it may exist, not necessarily true.")),(0,l.yg)("p",null,"Bloom filter is actually composed of an extremely long binary bit array and a series of hash functions. The binary bit array is all 0 initially. When an element to be queried is given, this element will be calculated by a series of hash functions to map out a series of values, and all values are treated as 1 in the offset of the bit array."),(0,l.yg)("p",null,"Figure below shows an example of Bloom Filter with m=18, k=3 (m is the size of the Bit array, and k is the number of Hash functions). The three elements of x, y, and z in the set are hashed into the bit array through three different hash functions. When querying the element w, after calculating by the Hash function, because one bit is 0, w is not in the set."),(0,l.yg)("p",null,"Similarly, if an element undergoes a hash function calculation to obtain all its offset positions, and if all these positions are set to 1, then it is determined that this element is in the set."),(0,l.yg)("p",null,(0,l.yg)("img",{alt:"Bloom_filter.svg",src:i(315846).A,width:"2560",height:"960"})),(0,l.yg)("p",null,"Bloom Filter is a data structure that allows for a reverse test on the data stored in each data block. When a specific row is requested, the Bloom Filter first checks if that row is not in the data block. The Bloom Filter either confidently states that the row is not present or it gives an uncertain answer. This uncertainty is why it's called a reverse test. However, Bloom Filters are not without cost. Storing this additional index level consumes extra space, and Bloom Filters grow as the data they index grows."),(0,l.yg)("p",null,"In Doris, BloomFilter indexes can be specified during table creation or through ALTER table operations. Essentially, a Bloom Filter is a bitmap structure used to quickly determine if a given value is in a set. This determination can result in a small probability of false positives. That is, if it returns false, the value is definitely not in the set. But if it returns true, the value might be in the set."),(0,l.yg)("p",null,"BloomFilter indexes in Doris are created at the Block level. Within each Block, the values of specified columns are treated as a set to generate a BloomFilter index entry. This entry is used during queries to quickly filter out data that doesn't meet the conditions."),(0,l.yg)("p",null,"Now let's see how Doris creates a BloomFilter index through an example."),(0,l.yg)("h3",{id:"create-bloomfilter-index"},"Create BloomFilter index"),(0,l.yg)("p",null,"The Doris BloomFilter index is created by adding ",(0,l.yg)("inlineCode",{parentName:"p"},'"bloom_filter_columns"="k1,k2,k3"')," to the PROPERTIES of the table building statement, this attribute, k1,k2,k3 is the Key column name of the BloomFilter index you want to create, for example, we Create a BloomFilter index for the saler_id and category_id in the table."),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE IF NOT EXISTS sale_detail_bloom (\n    sale_date date NOT NULL COMMENT "Sales time",\n    customer_id int NOT NULL COMMENT "Customer ID",\n    saler_id int NOT NULL COMMENT "Salesperson",\n    sku_id int NOT NULL COMMENT "Product ID",\n    category_id int NOT NULL COMMENT "Product Category",\n    sale_count int NOT NULL COMMENT "Sales Quantity",\n    sale_price DECIMAL(12,2) NOT NULL COMMENT "unit price",\n    sale_amt DECIMAL(20,2) COMMENT "Total sales amount"\n)\nDuplicate KEY(sale_date, customer_id,saler_id,sku_id,category_id)\nPARTITION BY RANGE(sale_date)\n(\nPARTITION P_202111 VALUES [(\'2021-11-01\'), (\'2021-12-01\'))\n)\nDISTRIBUTED BY HASH(saler_id) BUCKETS 10\nPROPERTIES (\n"replication_num" = "3",\n"bloom_filter_columns"="saler_id,category_id",\n"dynamic_partition.enable" = "true",\n"dynamic_partition.time_unit" = "MONTH",\n"dynamic_partition.time_zone" = "Asia/Shanghai",\n"dynamic_partition.start" = "-2147483648",\n"dynamic_partition.end" = "2",\n"dynamic_partition.prefix" = "P_",\n"dynamic_partition.replication_num" = "3",\n"dynamic_partition.buckets" = "3"\n);\n')),(0,l.yg)("h3",{id:"view-bloomfilter-index"},"View BloomFilter index"),(0,l.yg)("p",null,"Check that the BloomFilter index we built on the table is to use:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-sql"},"SHOW CREATE TABLE <table_name>;\n")),(0,l.yg)("h3",{id:"delete-bloomfilter-index"},"Delete BloomFilter index"),(0,l.yg)("p",null,"Deleting the index is to remove the index column from the ",(0,l.yg)("inlineCode",{parentName:"p"},"bloom_filter_columns attribute"),":"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-sql"},'ALTER TABLE <db.table_name> SET ("bloom_filter_columns" = "");\n')),(0,l.yg)("h3",{id:"modify-bloomfilter-index"},"Modify BloomFilter index"),(0,l.yg)("p",null,"Modifying the index is to modify the ",(0,l.yg)("inlineCode",{parentName:"p"},"bloom_filter_columns")," attribute of the table:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-sql"},'ALTER TABLE <db.table_name> SET ("bloom_filter_columns" = "k1,k3");\n')),(0,l.yg)("h3",{id:"bloomfilter-usage-scenarios"},(0,l.yg)("strong",{parentName:"h3"},"BloomFilter usage scenarios")),(0,l.yg)("p",null,"User can create a BloomFilter index for a column when the following conditions are met:"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("p",{parentName:"li"},"BloomFilter is suitable for non-prefix filtering.")),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("p",{parentName:"li"},"The query will be filtered according to the high frequency of the column, and most of the query conditions are ",(0,l.yg)("inlineCode",{parentName:"p"},"in")," and ",(0,l.yg)("inlineCode",{parentName:"p"},"= "),"filtering.")),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("p",{parentName:"li"},"BloomFilter is suitable for high cardinality columns. Such as UserID. Because if it is created on a low-cardinality column, such as a ",(0,l.yg)("inlineCode",{parentName:"p"},"gender")," column, each Block will almost contain all values, causing the BloomFilter index to lose its meaning."))),(0,l.yg)("h3",{id:"bloomfilter-use-precautions"},(0,l.yg)("strong",{parentName:"h3"},"BloomFilter use precautions")),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("p",{parentName:"li"},"It does not support the creation of BloomFilter indexes for ",(0,l.yg)("inlineCode",{parentName:"p"},"Tinyint"),",",(0,l.yg)("inlineCode",{parentName:"p"},"Float"),", and ",(0,l.yg)("inlineCode",{parentName:"p"},"Double")," columns.")),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("p",{parentName:"li"},"The BloomFilter index only has an acceleration effect on ",(0,l.yg)("inlineCode",{parentName:"p"},"in")," and ",(0,l.yg)("inlineCode",{parentName:"p"},"=")," filtering queries.")),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("p",{parentName:"li"},"If you want to check whether a query hits the BloomFilter index, you can check the profile information of the query."))))}u.isMDXComponent=!0},315846:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/Bloom_filter.svg-e437ea5c65c96143c00cdb97711e1b10.png"}}]);