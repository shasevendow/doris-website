"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[97399],{15680:(e,n,a)=>{a.d(n,{xA:()=>d,yg:()=>g});var t=a(296540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var u=t.createContext({}),s=function(e){var n=t.useContext(u),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},d=function(e){var n=s(e.components);return t.createElement(u.Provider,{value:n},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,u=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(a),m=i,g=c["".concat(u,".").concat(m)]||c[m]||p[m]||r;return a?t.createElement(g,o(o({ref:n},d),{},{components:a})):t.createElement(g,o({ref:n},d))}));function g(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=m;var l={};for(var u in n)hasOwnProperty.call(n,u)&&(l[u]=n[u]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=a[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},758771:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var t=a(58168),i=(a(296540),a(15680));const r={title:"Using AUTO_INCREMENT",language:"en"},o=void 0,l={unversionedId:"table-design/auto-increment",id:"version-2.0/table-design/auto-increment",title:"Using AUTO_INCREMENT",description:"\x3c!--",source:"@site/versioned_docs/version-2.0/table-design/auto-increment.md",sourceDirName:"table-design",slug:"/table-design/auto-increment",permalink:"/docs/2.0/table-design/auto-increment",draft:!1,tags:[],version:"2.0",frontMatter:{title:"Using AUTO_INCREMENT",language:"en"},sidebar:"docs",previous:{title:"Inverted Index",permalink:"/docs/2.0/table-design/index/inverted-index"},next:{title:"Best Practices",permalink:"/docs/2.0/table-design/best-practice"}},u={},s=[{value:"Description",id:"description",level:2},{value:"Uniqueness",id:"uniqueness",level:3},{value:"Sequentialness",id:"sequentialness",level:3},{value:"Usage",id:"usage",level:2},{value:"Applicable scenarios",id:"applicable-scenarios",level:2},{value:"Dictionary encoding",id:"dictionary-encoding",level:3},{value:"Efficient pagination",id:"efficient-pagination",level:3}],d={toc:s},c="wrapper";function p(e){let{components:n,...a}=e;return(0,i.yg)(c,(0,t.A)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Auto-increment column is supported in Doris since version 2.1. The documentation of V2.0 only provides an introduction to its functionality and use cases. If you are interested in this feature, please upgrade to Doris 2.1 and refer to the relevant part in the documentation of V2.1.")),(0,i.yg)("p",null,"For tables that enable an AUTO_INCREMENT Column, Doris assigns a table-unique value to rows that do not have a specified value in the auto-increment column."),(0,i.yg)("h2",{id:"description"},"Description"),(0,i.yg)("p",null,"For tables that contain an auto-increment column, during data ingestion:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"If the auto-increment column is ",(0,i.yg)("strong",{parentName:"li"},"NOT")," one of the target columns of this import, it will be auto-filled with values generated by Doris. The auto-filled values are unique for each row."),(0,i.yg)("li",{parentName:"ul"},"If the auto-increment column is one of the target columns of this import, the imported null values in this column will be replaced with values generated by Doris, while non-null values will remain unchanged. Note that the existence of the imported non-null values might compromise the uniqueness of values in the auto-increment columns.")),(0,i.yg)("h3",{id:"uniqueness"},"Uniqueness"),(0,i.yg)("p",null,"Doris ensures that the values generated on the auto-increment column are unique within the table. However, Doris can only guarantee the uniqueness of values generated by itself. If the user inserts values into the auto-increment column explicitly, it does not guarantee the table-wide uniqueness of such values."),(0,i.yg)("h3",{id:"sequentialness"},"Sequentialness"),(0,i.yg)("p",null,"Doris ensures that the values generated on the auto-increment column are dense. However, it does not guarantee that the values populated by auto-increment during a single import will be completely continuous. This is because, for performance reasons, each backend (BE) caches a portion of pre-allocated auto-increment values, and the cached values do not overlap between different BEs. Additionally, due to the existence of caching, Doris cannot guarantee that the auto-increment values generated in a subsequent import will be larger than those generated in a previous import in terms of physical time. Therefore, the order of import cannot be determined based on the magnitude of auto-increment values allocated."),(0,i.yg)("h2",{id:"usage"},"Usage"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Create a table in the Duplicate Key model, with one of the key columns being an auto-increment column. ")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},'CREATE TABLE `demo`.`tbl` (\n      `id` BIGINT NOT NULL AUTO_INCREMENT,\n      `value` BIGINT NOT NULL\n) ENGINE=OLAP\nDUPLICATE KEY(`id`)\nDISTRIBUTED BY HASH(`id`) BUCKETS 10\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 3"\n);\n')),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},"Create a table in the Duplicate Key model, with one of the value columns being an auto-increment column. ")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},'CREATE TABLE `demo`.`tbl` (\n      `uid` BIGINT NOT NULL,\n      `name` BIGINT NOT NULL,\n      `id` BIGINT NOT NULL AUTO_INCREMENT,\n      `value` BIGINT NOT NULL\n) ENGINE=OLAP\nDUPLICATE KEY(`uid`, `name`)\nDISTRIBUTED BY HASH(`uid`) BUCKETS 10\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 3"\n);\n')),(0,i.yg)("ol",{start:3},(0,i.yg)("li",{parentName:"ol"},"Create a table in the Unique Key model, with one of the key columns being an auto-increment column.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},'CREATE TABLE `demo`.`tbl` (\n      `id` BIGINT NOT NULL AUTO_INCREMENT,\n      `name` varchar(65533) NOT NULL,\n      `value` int(11) NOT NULL\n) ENGINE=OLAP\nUNIQUE KEY(`id`)\nDISTRIBUTED BY HASH(`id`) BUCKETS 10\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 3",\n"enable_unique_key_merge_on_write" = "true"\n);\n')),(0,i.yg)("ol",{start:4},(0,i.yg)("li",{parentName:"ol"},"Create a table in the Unique Key model, with one of the value columns being an auto-increment column. ")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},'CREATE TABLE `demo`.`tbl` (\n      `text` varchar(65533) NOT NULL,\n      `id` BIGINT NOT NULL AUTO_INCREMENT,\n) ENGINE=OLAP\nUNIQUE KEY(`text`)\nDISTRIBUTED BY HASH(`text`) BUCKETS 10\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 3",\n"enable_unique_key_merge_on_write" = "true"\n);\n')),(0,i.yg)("h2",{id:"applicable-scenarios"},"Applicable scenarios"),(0,i.yg)("h3",{id:"dictionary-encoding"},"Dictionary encoding"),(0,i.yg)("p",null,"In user profiling, where bitmap is utilized for user group analysis, analysts often need to build a dictionary, in which each user corresponds to a unique integer value. Sequential dictionary values can improve bitmap performance."),(0,i.yg)("p",null,"Take offline UV (Unique Visitors) and PV (Page Views) analysis as an example, assume that all the detailed data is stored in the following user behavior table:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},'CREATE TABLE `demo`.`dwd_dup_tbl` (\n    `user_id` varchar(50) NOT NULL,\n    `dim1` varchar(50) NOT NULL,\n    `dim2` varchar(50) NOT NULL,\n    `dim3` varchar(50) NOT NULL,\n    `dim4` varchar(50) NOT NULL,\n    `dim5` varchar(50) NOT NULL,\n    `visit_time` DATE NOT NULL\n) ENGINE=OLAP\nDUPLICATE KEY(`user_id`)\nDISTRIBUTED BY HASH(`user_id`) BUCKETS 32\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 3"\n);\n')),(0,i.yg)("p",null,"Create a dictionary table using AUTO_INCREMENT:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},'CREATE TABLE `demo`.`dictionary_tbl` (\n    `user_id` varchar(50) NOT NULL,\n    `aid` BIGINT NOT NULL AUTO_INCREMENT\n) ENGINE=OLAP\nUNIQUE KEY(`user_id`)\nDISTRIBUTED BY HASH(`user_id`) BUCKETS 32\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 3",\n"enable_unique_key_merge_on_write" = "true"\n);\n')),(0,i.yg)("p",null,"Load the existing ",(0,i.yg)("inlineCode",{parentName:"p"},"user_id")," into the dictionary table, and create mappings from ",(0,i.yg)("inlineCode",{parentName:"p"},"user_id")," to integer values:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"insert into dit_tbl(user_id)\nselect user_id from dwd_dup_tbl group by user_id;\n")),(0,i.yg)("p",null,"Or load the incremental ",(0,i.yg)("inlineCode",{parentName:"p"},"user_id")," into the dictionary table:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"insert into dit_tbl(user_id)\nselect dwd_dup_tbl.user_id from dwd_dup_tbl left join dictionary_tbl\non dwd_dup_tbl.user_id = dictionary_tbl.user_id where dwd_dup_tbl.visit_time  '2023-12-10' and dictionary_tbl.user_id is NULL;\n")),(0,i.yg)("p",null,"You can also use the Flink-Doris-Connector to load data into Doris."),(0,i.yg)("p",null,"Suppose that ",(0,i.yg)("inlineCode",{parentName:"p"},"dim1"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"dim3"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"dim5")," are the analytic dimensions to be considered, create an Aggregate Key table to accommodate the results of data aggregation."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},'CREATE TABLE `demo`.`dws_agg_tbl` (\n    `dim1` varchar(50) NOT NULL,\n    `dim3` varchar(50) NOT NULL,\n    `dim5` varchar(50) NOT NULL,\n    `user_id_bitmap` BITMAP BITMAP_UNION NOT NULL,\n    `pv` BIGINT SUM NOT NULL \n) ENGINE=OLAP\nAGGREGATE KEY(`dim1`,`dim3`,`dim5`)\nDISTRIBUTED BY HASH(`user_id`) BUCKETS 32\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 3"\n);\n')),(0,i.yg)("p",null,"Load the aggregated results into the table:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"insert into dws_tbl\nselect dwd_dup_tbl.dim1, dwd_dup_tbl.dim3, dwd_dup_tbl.dim5, BITMAP_UNION(TO_BITMAP(dictionary_tbl.aid)), COUNT(1)\nfrom dwd_dup_tbl INNER JOIN dictionary_tbl on dwd_dup_tbl.user_id = dictionary_tbl.user_id;\n")),(0,i.yg)("p",null,"Then query PV/UV using the following statement:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"select dim1, dim3, dim5, user_id_bitmap as uv, pv from dws_agg_tbl;\n")),(0,i.yg)("h3",{id:"efficient-pagination"},"Efficient pagination"),(0,i.yg)("p",null,"Pagination is often required in data display. Typically, pagination is implemented by SQL statements like ",(0,i.yg)("inlineCode",{parentName:"p"},"limit")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"offset")," + ",(0,i.yg)("inlineCode",{parentName:"p"},"order by"),". Suppose that you need to display the following table:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},'CREATE TABLE `demo`.`records_tbl` (\n    `key` int(11) NOT NULL COMMENT "",\n    `name` varchar(26) NOT NULL COMMENT "",\n    `address` varchar(41) NOT NULL COMMENT "",\n    `city` varchar(11) NOT NULL COMMENT "",\n    `nation` varchar(16) NOT NULL COMMENT "",\n    `region` varchar(13) NOT NULL COMMENT "",\n    `phone` varchar(16) NOT NULL COMMENT "",\n    `mktsegment` varchar(11) NOT NULL COMMENT ""\n) DUPLICATE KEY (`key`, `name`)\nDISTRIBUTED BY HASH(`key`) BUCKETS 10\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 3"\n);\n')),(0,i.yg)("p",null,"In pagination queries, if each page displays 100 results, you can retrieve the first page using the following SQL statement: "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"select * from records_tbl order by key, name limit 100;\n")),(0,i.yg)("p",null,"You can retrieve the second page using the following SQL statement: "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"select * from records_tbl order by key, name limit 100, offset 100;\n")),(0,i.yg)("p",null,"However, when performing deep pagination queries (with a large offset), even if only a few rows of data are actually requested, the previous method still reads all the data into memory, performs a full sorting, and then proceeds with further processing. For higher execution efficiency, you can assign a unique value to each row of data using an auto-increment column. This method records the maximum value of the ",(0,i.yg)("inlineCode",{parentName:"p"},"unique_value")," column from the previous page and uses the ",(0,i.yg)("inlineCode",{parentName:"p"},"where unique_value > max_value limit rows_per_page")," clause to push down the predicate and filter out a significant amount of data in advance, thereby achieving more efficient pagination."),(0,i.yg)("p",null,"In the above example table, you can add an auto-increment column to the table to assign a unique identifier to each row:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},'CREATE TABLE `demo`.`records_tbl2` (\n    `key` int(11) NOT NULL COMMENT "",\n    `name` varchar(26) NOT NULL COMMENT "",\n    `address` varchar(41) NOT NULL COMMENT "",\n    `city` varchar(11) NOT NULL COMMENT "",\n    `nation` varchar(16) NOT NULL COMMENT "",\n    `region` varchar(13) NOT NULL COMMENT "",\n    `phone` varchar(16) NOT NULL COMMENT "",\n    `mktsegment` varchar(11) NOT NULL COMMENT "",\n    `unique_value` BIGINT NOT NULL AUTO_INCREMENT\n) DUPLICATE KEY (`key`, `name`)\nDISTRIBUTED BY HASH(`key`) BUCKETS 10\nPROPERTIES (\n    "replication_num" = "3"\n);\n')),(0,i.yg)("p",null,"In pagination queries, suppose that each page displays 100 results, you can retrieve the first page by: "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"select * from records_tbl2 order by unique_value limit 100;\n")),(0,i.yg)("p",null,"Use programs to record the maximum ",(0,i.yg)("inlineCode",{parentName:"p"},"unique_value")," in the returned result. Suppose that the maximum is 99, you can query data from the second page by:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"select * from records_tbl2 where unique_value  99 order by unique_value limit 100;\n")),(0,i.yg)("p",null,"If you need to query data from a deeper page, for example, page 101, which means it's hard to get the maximum ",(0,i.yg)("inlineCode",{parentName:"p"},"unique_value")," from the previous page directly, then you can use the statement as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"select key, name, address, city, nation, region, phone, mktsegment\nfrom records_tbl2, (select uniuqe_value as max_value from records_tbl2 order by uniuqe_value limit 1 offset 9999) as previous_data\nwhere records_tbl2.uniuqe_value  previous_data.max_value\norder by unique_value limit 100;\n")))}p.isMDXComponent=!0}}]);